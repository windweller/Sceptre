program  ->  declarations
declarations -> declaration declarations | declaration
declaration -> var-declaration | fun-declaration
var-declaration -> type ID; | type ID[NUM];
type  -> int | void
fun-declaration -> type ID (formals) block
formals -> void | parameters
parameters -> parameter, parameters | parameter
parameter -> type ID | type ID[]
block -> {local-vars statements}
local-vars  -> var-declaration local-vars | ε
statements -> statement statements | ε
statement -> expr-stmt | block | selection | break; | repetition | return-stmt | $expr
expr-stmt -> experssion; | ;
selection -> if ( comparison ) statement |
			  if ( comparison ) with-else else statement
with-else -> if (comparison) with-else else with-else
repetition -> while ( comparison ) statement
return-stmt -> return; | return expression;
expression -> var = expression | arith-expr
var -> ID | ID[expression]
comparison -> arith-expr relop arith-expr | ! ( comparison )
relop -> <= | < | > | >= | == | !=
arith-expr -> arith-term arith-expr* 
arith-expr* -> + arith-term arith-expr* | - arith-term arith-expr* | ε
arith-term -> arith-factor arith-term*
arith-term* -> * arith-factor arith-term* | / arith-factor arith-term* | ε
arith-factor -> var | call | NUM | (expression)
call -> ID(actuals)
actuals -> ε | arguments
arguments -> argument, arguments | argument
argument -> expression


http://hackingoff.com/compilers/predict-first-follow-set
-------

program  ->  declarations
declarations -> declaration declarations | declaration
declaration -> var-declaration | fun-declaration
var-declaration -> type ID ; | type ID [ NUM ] ;
type  -> int | void
fun-declaration -> type ID ( formals ) block
formals -> void | parameters
parameters -> parameter , parameters | parameter
parameter -> type ID | type ID [ ]
block -> { local-vars statements }
local-vars  -> var-declaration local-vars | EPSILON
statements -> statement statements | EPSILON
statement -> expr-stmt | block | selection | break ; | repetition | return-stmt | $ expr
expr-stmt -> experssion ; | ;
selection -> if ( comparison ) statement | if ( comparison ) with-else else statement
with-else -> if ( comparison ) with-else else with-else
repetition -> while ( comparison ) statement
return-stmt -> return ; | return expression ;
expression -> var = expression | arith-expr
var -> ID | ID [ expression ]
comparison -> arith-expr relop arith-expr | ! ( comparison )
relop -> <= | < | > | >= | == | !=
arith-expr -> arith-term arith-expr* 
arith-expr* -> + arith-term arith-expr* | - arith-term arith-expr* | EPSILON
arith-term -> arith-factor arith-term*
arith-term* -> * arith-factor arith-term* | / arith-factor arith-term* | EPSILON
arith-factor -> var | call | NUM | ( expression )
call -> ID ( actuals )
actuals -> EPSILON | arguments
arguments -> argument , arguments | argument
argument -> expression